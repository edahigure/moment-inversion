#include	<stdio.h>
#define MAX	  100
#define MAXDATA	10000
#define COMMENT	'#'
char symnamefile[64]	= "../plotsubs/symbolname.h";
char symdatafile[64]	= "../devs/com/symboldata.h";

struct symbolnames
   {
	char	*symname;
	int	 symnum;
   }	sn[MAX];
struct symbolhead
   {
	int npoints;
	int index;
   }	sh[MAX];
struct symboldata
   {
	float	xp;
	float	yp;
   }	sd[MAXDATA];
char namebuf[MAX][64];
int	nsym	=0;
int	nname	=0;
int	ndata	=0;
int	linenum	=0;

main(ac,av)
int ac; char **av;
   {
	int i, k, n, nargs, np;
	float *fptr, xcen, ycen;
	char line[128], *args[64];
	double atof();
	FILE *fd, *fopen();

	linenum= 0;
	while( (n=getline(stdin,line)) >= 0)
	   {
		linenum++;
		if(n == 0) continue;	/* blank line */
		if(line[0] == COMMENT) continue;	/* comment */
		if(line[0] != '+')
			err("expecting a '+' field");
		nargs= setpointers(&line[1],args);
		if(nargs < 4)
			err("expecting 4 at least arguments in '+' field");
		strcpy(namebuf[nname],args[0]);
		np  = atoi(args[1]);
		xcen= atof(args[2]);
		ycen= atof(args[3]);
		sn[nname].symname= namebuf[nname];
		sn[nname].symnum = nsym;
		nname++;
		/* enter 'other' names */
		for(i=4; i<nargs; i++)
		   {
			strcpy(namebuf[nname],args[i]);
			sn[nname].symname= namebuf[nname];
			sn[nname].symnum = nsym;
			nname++;
		   }
		sh[nsym].npoints= np;
		sh[nsym].index  = ndata;
		fptr= (float *)( &sd[ndata] );

		for(i=0; i<2*np; /* inc at bottom of loop */)
		   {
			linenum++;
			if( (n= getline(stdin,line)) < 0)
				err("unexpected EOF");
			if(n == 0) continue;
			if(line[0] == COMMENT) continue;
			if(line[0] == '+')
				err("not enough points");
			nargs= setpointers(line,args);
			for(k=0; k<nargs; k++)
				fptr[i+k]= atof(args[k]);
			i += nargs;
		   }
		for(i=0; i<np; i++)
		   {
			sd[ndata+i].xp -= xcen;
			sd[ndata+i].yp -= ycen;
		   }
		ndata += np;
		nsym++;
	   }
	
	/* output symbolname file */
	if( (fd=fopen(symnamefile,"w")) == NULL)
	   {
		fprintf(stderr,"cannot creat %s\n",symnamefile);
		fprintf(stderr,"no output generated\n");
		exit(-1);
	   }
	
	fprintf(fd,"/* DO NOT MODIFY THIS FILE */\n");
	fprintf(fd,"/* It is machine generated by 'make_symbol_structs' */\n");
	fprintf(fd,"/* It will be overwritten when a symbol is added or modified */\n");
	fprintf(fd,"#define NSYMBOL	%d\n",nsym);
	fprintf(fd,"struct symbolname\n   {\n\tchar\t*symname;\n\tint\t symnum;\n   }\tsymnames[] = {\n");
	for(i=0; i<nname; i++)
	   {
		fprintf(fd,"\t\"%s\",\t%d,\n",sn[i].symname,sn[i].symnum);
	   };
	/* terminator */
	fprintf(fd,"\t\"\",\t-1  };\n");
	fclose(fd);

	/* output symboldata file */
	if( (fd=fopen(symdatafile,"w")) == NULL)
	   {
		fprintf(stderr,"cannot creat %s\n",symdatafile);
		fprintf(stderr,"WARNING file %s is now invalid\n",symnamefile);
		exit(-1);
	   }
	fprintf(fd,"/* DO NOT MODIFY THIS FILE */\n");
	fprintf(fd,"/* It is machine generated by 'make_symbol_structs' */\n");
	fprintf(fd,"/* It will be overwritten when a symbol is added or modified */\n");
	fprintf(fd,"#define NSYMBOL	%d\n",nsym);
	fprintf(fd,"struct symbolhead\n   {\n\tint\tnpoints;\n\tint\t index;\n   }\tsymheads[NSYMBOL+1] = {\n");
	for(i=0; i<nsym; i++)
	   {
		fprintf(fd,"\t%d,\t%d,\n",sh[i].npoints,sh[i].index);
	   };
	/* terminator */
	fprintf(fd,"\t0,\t-1  };\n");
	fprintf(fd,"\n");
	fprintf(fd,"struct symboldata\n   {\n\tfloat\txp, yp;\n   }\tsymdata[] = {\n");
	for(i=0; i<ndata; i++)
	   {
		fprintf(fd,"\t%7.4f,\t%7.4f,\n",sd[i].xp,sd[i].yp);
	   };
	/* terminator */
	fprintf(fd,"\t0.0,\t0.0  };\n");
	fclose(fd);
   }

getline(fd,line)
FILE *fd;
char *line;
   {
	char c;
	int n;

	n=0;
	while( (c=getc(fd)) != EOF)
	   {
		if(c == '\n')
		   {
			*line= '\0';
			return(n);
		   }
		*line++ = c;
		n++;
	   }
	return(EOF);
   }

err(mess,a1,a2,a3,a4,a5)
char *mess;
int a1,a2,a3,a4,a5;
   {
	fprintf(stderr,"error near line %d\n",linenum);
	fprintf(stderr,mess,a1,a2,a3,a4,a5);
	fprintf(stderr,"\n");
	exit(-1);
   }
setpointers(list, ptrs)
char *list, *ptrs[];
   {
	int n;

	n=0;
	while( *list != '\0' )
	   {
		while(*list == ' ' || *list == '\t') list++;
		if(*list == '\0') break;
		ptrs[n]= list;
		n++;
		while(*list != ' ' && *list != '\t' && *list != '\0') list++;
		if(*list == '\0') break;
		*list++ = '\0';
	   }
	return(n);
   }
